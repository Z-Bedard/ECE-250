CLASS DESIGN

The classes I implemented were a class for the linked list (CountryList) and a class for the nodes (NodeData) within the linked list. I resused my TimeSeries class from project one to create the data for the nodes. In the NodeData class I take in a country name and import it into a new node. To find the desired value the LOAD function checks the first index of each row to see if it matches the desired country. The NodeData class also holds the PRINT function called by the CountryList class when one node is wanted for printing. The CountryList class is where all of the other functions are. LIST, BIGGEST, ADD, UPDATE, and DELETE all require going through the list and then editing the node, either by calling a TimeSeries function or doing the computations in the CountryList class. LIST goes through the list and prints the appropriate data for each node. BIGGEST stores a value for the biggest average, calls the MEAN function from TimeSeries to calculate the mean of each nodes data, and updates the saved value accordingly. Once the end of the list is reached it outputs the appropriate data code. ADD and UPDATE are the same as project one, but before calling those functions from TimeSeries it iterates through the list to find the appropriate node that needs to be edited. 

ALTERNATIVES AND JUSTIFICATION

I decided to use a linked list of TimeSeries objects over using a 2D array to store the country data or use 2 separate arrays to store the data and the titles (country name, code, data name, data code). My initial idea was to create a resizable 2D array with the each row corresponding to a set of data from the CSV file. Originally I thought this to try and reuse a lot of what I did in project one to streamline the development, however the more I dug into that plan the more I realized that there would be a lot of unexpected issues with this including the data in memory not being stored contiguously (as we learned from ECE 222). After that I thought about doing something similar to what I did with project one, using a separate array to identify the data sets. This approach quickly proved to be problematic when the identity array (with the country name, etc.) would be a dynamically allocated array of dynamically allocated arrays (strings). That screamed memory issues the moment I started trying to design the program.

RUNTIME ANALYSIS

The worst case runtime for the DELETE command is O(N+m) where N is the number of nodes in the linked list and m is the number of data points in the node. The DELETE function would first have to iterate through the linked list and find the node to delete (N could be the last node in the linked list). Each node would take O(1) time to get there from the previous node. Multiply this by the number of nodes (N) you get O(N) for iterating through the list. The +m comes when you have to delete every piece of data from the node individually using the destructor from the TimeSeries class, resulting in a total runtime of O(N+m). The worst case runtime for the ADD function is also O(N+m). The base O(N) runtime is the same reasoning as DELETE where you have to iterate through the whole linked list to find the desired node to edit (O(1) time complexity for each individual node), which could be the last node in the list. The +m comes from finding where the new value should go. If the new value comes after the final value in the desired node then you'd have to iterate through the whole array of data within that node which we've established is m. This results in the runtime being O(N+m)