CLASS DESIGN

The classes I implemented this project were identical to the classes in project 3 with the addition of LOOKUP, REMOVE, and INSERT functions being added to NodeData and DataTree classes as well as hash functions being added to add countries to the data array. The NodeData class is used to organize the Nodes in a CountryList object which holds all the appropriate timeseries from the CSV file. The hash function has been added to the NodeData class because NodeData is used to create the objects in the array. Every time the create function is called it uses the Hash function as well as the secondary hash function to compute where the current country should. LOOKUP and INSERT directly interact with the CountryList Objects in each node within the array of CountryLists so they have also been added to the NodeData class. The REMOVE function has been integrated into the binary tree class. This is because it interacts with the Tree when the tree is built, unlike the other two functions. The REMOVE function should remove the desired country from the array and check if the country is in the binary tree. If the tree is found to be built (using the isBuilt variable in the DataTree class) the remove function from the DataTree class is called. With the REMOVE function integrated into the Tree class it lets me use the isBuilt status boolean to determine if the REMOVE function should remove the value from the tree.

ALTERNATIVES AND JUSTIFICATION

Alternatives to the way this hash function was implemented was to instead use a different probing method or use external chaining instead. Potential alternative probing methods are linear probing and quadratic probing. Both of these could result in issues. Linear probing could result in data being clustered in weird spots on the array and will eventually lead to insertion time complexity approaching O(N), defeating the purpose of hashing in the first place. Quadratic probing could also leading to secondary collisions within the hash function leading to the time complexity leading to O(N) as well. External chaining would also be non-ideal as this would mean searching a second list (possibly sequentially) for the desired value which takes O(N) time, once again defeating the purpose of hashing.

RUNTIME ANALYSIS

The LOOKUP function has an average-best case runtime of O(1) due to the hash function. With the hash function we can directly compute the desired index to check. The best case runtime is where the desired index will have no collisions and the hash function will compute the right index in one function call resulting in O(1) time. In the event that there is a collision the hash function then calls the secondary hash function to detect the desired value. It will run the secondary hash functions once for each collision. However, given how we have designed the hash function there should never be more than 2 secondary hash function calls. Collisions are rare with this hash implementation so most of the lookups require only one computation, resulting in an average runtime of O(1). The worst case runtime is O(N) when the array is almost full or the desired country is not found in the array. When the array is close to being full the chance of collisions is much higher. With the chance of collision increasing it approaches a guarenteed collision which would reuslt in an O(N) runtime for LOOKUP. If the desired country isn't in the array then the LOOKUP function will search every index in the array until it has searched all of them resulting in a worst case runtime of O(N).