CLASS DESIGN

For this project I implemented a new class called GRAPH. The GRAPH class handles the creation and functions to relate our data through the tree. The graph in this project is implemented using an adjacency list. All of the new functions (UPDATE_EDGES, ADJACENT, PATH, and RELATIONSHIPS) are within the graph class as they directly interact with the graph. The vertices (which I will refer to as nodes throughout this design document) are stored in a vector of pointers. The edges are stored in an unordered map. The map made most sense as each edge could be stored under the countrys code with each code being a key. UPDATE_EDGES uses the FIND logic from Project 3 to determine which countries should be connected via edges. When INITIALIZE is called we use the array from the Project4 to create nodes that correspond to each country. For every populated index in the array, a node for the graph is created that holds the countries name and code, making outputs and comparison possible with either one. ADJACENT takes in a country code and finds that corresponding country code in the map as one of the keys. When that key is found you can see every country that's directly connected to the desired country via the map. For the PATH function I used a BFS path finding function to see if it's possible to connect the nodes no matter how far the connection. RELATIONSHIPS uses a comparison between the two input countries. It takes two country codes and finds the corresponding nodes. It then takes those nodes and finds the list of edges using the input country code as the key to search the map. It then checks the keys to see if those countries both have any edges leading to the other. 

ALTERNATIVES AND JUSTIFICATION

The alternatives for this project were to implement the graph using an adjaceny matrix instead of a list, and using a DFS rather than a BFS. I decided aganist using the adjacency matrix because of the space it takes up and the time it takes to find the corresponding edges. An adjacency matrix will use V^2 space (V being the number of nodes) where the adjacency list uses V+E space (where E is the number of edges). When the graph is initialized there are no edges so the space used is much smaller. As edges are added the space will increase, but it won't reach the level that is used by an adjacency list. For the PATH function I decided to use a BFS rather than a DFS. I decided this because BFS path finding algorithms are easier to track and (in the event that we want it) find shortest paths rather then scattering them all over the place.

RUNTIME ANALYSIS

the runtime of my ADJACENT function is O(V+E) with V being the number of nodes and E being the number of edges. The ADJACENT function has three parts: find the appropriate node within the graph, find the edges in the map, and then find the correct edges under the right map key. Finding the node within the graph means iterating through the Vector holding all the nodes, which is O(V). Finding the edges with the appropriate country code in the map is O(1)[1] as the map in the standard library is based on a hash table which we know from class has an average lookup time of O(1).The lookup function finds the index within the map with the right key to show all the edges that are connected to the country. With these two steps we have a runtime of O(V). With our third step we need to take the edges found under the proper key. In this case it would be E number of edges stored within the map under that key so getting all the edges has a runtime of O(E). Putting all the runtimes together leaves us with O(V+E)

Citations:

[1]“unordered_map in C++ STL,” GeeksforGeeks.org, Mar. 24, 2016. https://www.geeksforgeeks.org/unordered_map-in-cpp-stl/ (accessed Mar. 26 2025)
‌